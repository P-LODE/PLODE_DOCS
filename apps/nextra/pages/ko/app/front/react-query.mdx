# React Query (TanStack Query)

React Query는 서버 상태 관리를 위한 강력한 라이브러리입니다.

## 주요 특징

- **자동 캐싱**: 서버 데이터를 자동으로 캐싱합니다
- **백그라운드 업데이트**: 오래된 데이터를 자동으로 갱신합니다
- **중복 요청 제거**: 같은 데이터에 대한 중복 요청을 방지합니다
- **페이지네이션**: 페이지네이션과 무한 스크롤을 쉽게 구현
- **낙관적 업데이트**: UI 반응성을 향상시킵니다

## 설치하기

```bash
npm install @tanstack/react-query
```

DevTools (개발 환경):

```bash
npm install @tanstack/react-query-devtools
```

## 기본 설정

```tsx
// App.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5분
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

export default App;
```

## 데이터 조회 (useQuery)

```tsx
import { useQuery } from '@tanstack/react-query';

interface User {
  id: number;
  name: string;
  email: string;
}

async function fetchUsers(): Promise<User[]> {
  const response = await fetch('https://api.example.com/users');
  if (!response.ok) {
    throw new Error('네트워크 오류');
  }
  return response.json();
}

function UserList() {
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });

  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>오류: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>새로고침</button>
      <ul>
        {data?.map(user => (
          <li key={user.id}>
            {user.name} - {user.email}
          </li>
        ))}
      </ul>
    </div>
  );
}

export default UserList;
```

## 데이터 수정 (useMutation)

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

interface CreateUserData {
  name: string;
  email: string;
}

async function createUser(userData: CreateUserData): Promise<User> {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(userData),
  });
  return response.json();
}

function CreateUserForm() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // 사용자 목록을 다시 가져옵니다
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    mutation.mutate({
      name: formData.get('name') as string,
      email: formData.get('email') as string,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" placeholder="이름" required />
      <input name="email" type="email" placeholder="이메일" required />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? '생성 중...' : '사용자 생성'}
      </button>
      {mutation.isError && (
        <div>오류: {mutation.error.message}</div>
      )}
      {mutation.isSuccess && (
        <div>사용자가 생성되었습니다!</div>
      )}
    </form>
  );
}

export default CreateUserForm;
```

## 낙관적 업데이트

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

function TodoItem({ todo }: { todo: Todo }) {
  const queryClient = useQueryClient();

  const toggleMutation = useMutation({
    mutationFn: async (id: number) => {
      const response = await fetch(`https://api.example.com/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !todo.completed }),
      });
      return response.json();
    },
    // 낙관적 업데이트
    onMutate: async (id) => {
      // 진행 중인 refetch를 취소
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // 이전 값을 저장
      const previousTodos = queryClient.getQueryData(['todos']);

      // 낙관적으로 업데이트
      queryClient.setQueryData(['todos'], (old: Todo[] | undefined) => {
        return old?.map(t =>
          t.id === id ? { ...t, completed: !t.completed } : t
        );
      });

      return { previousTodos };
    },
    // 실패 시 롤백
    onError: (err, id, context) => {
      queryClient.setQueryData(['todos'], context?.previousTodos);
    },
    // 항상 refetch
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  return (
    <div>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => toggleMutation.mutate(todo.id)}
      />
      <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
        {todo.title}
      </span>
    </div>
  );
}
```

## 무한 스크롤

```tsx
import { useInfiniteQuery } from '@tanstack/react-query';

interface PostsResponse {
  posts: Post[];
  nextCursor: number | null;
}

async function fetchPosts({ pageParam = 0 }): Promise<PostsResponse> {
  const response = await fetch(`https://api.example.com/posts?cursor=${pageParam}`);
  return response.json();
}

function InfinitePostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: 0,
  });

  return (
    <div>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.posts.map(post => (
            <div key={post.id}>
              <h3>{post.title}</h3>
              <p>{post.content}</p>
            </div>
          ))}
        </div>
      ))}
      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? '로딩 중...'
          : hasNextPage
          ? '더 보기'
          : '더 이상 없습니다'}
      </button>
    </div>
  );
}

export default InfinitePostList;
```

## 언제 사용하나요?

- 서버 데이터를 다루는 모든 React 애플리케이션
- RESTful API 또는 GraphQL과 통신할 때
- 캐싱과 동기화가 필요할 때
- 복잡한 데이터 페칭 로직을 단순화하고 싶을 때
- 낙관적 업데이트가 필요한 경우

## Redux vs React Query

- **Redux**: 클라이언트 상태 관리 (UI 상태, 폼 데이터 등)
- **React Query**: 서버 상태 관리 (API 데이터, 캐싱 등)
- 함께 사용하면 각각의 장점을 활용할 수 있습니다

## 추가 자료

- [공식 문서](https://tanstack.com/query/latest)
- [React Query 예제](https://tanstack.com/query/latest/docs/react/examples/simple)
- [TanStack Query DevTools](https://tanstack.com/query/latest/docs/react/devtools)

