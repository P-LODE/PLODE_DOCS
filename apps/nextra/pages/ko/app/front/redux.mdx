# Redux

Redux는 JavaScript 애플리케이션을 위한 예측 가능한 상태 컨테이너입니다.

## 주요 특징

- **중앙 집중식 상태 관리**: 전역 상태를 한 곳에서 관리합니다
- **예측 가능성**: 상태 변경이 예측 가능하고 추적 가능합니다
- **디버깅 도구**: Redux DevTools로 시간 여행 디버깅
- **미들웨어 지원**: 비동기 로직을 쉽게 처리합니다
- **테스트하기 쉬움**: 순수 함수 기반으로 테스트가 간편합니다

## 설치하기

React 프로젝트에서:

```bash
npm install @reduxjs/toolkit react-redux
```

## 기본 예제 (Redux Toolkit 사용)

```typescript
// store/counterSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const initialState: CounterState = {
  value: 0
};

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;
```

```typescript
// store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

## React 컴포넌트에서 사용

```tsx
// App.tsx
import { Provider } from 'react-redux';
import { store } from './store';
import Counter from './Counter';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

export default App;
```

```tsx
// Counter.tsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from './store/counterSlice';
import type { RootState } from './store';

function Counter() {
  const count = useSelector((state: RootState) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <h2>카운트: {count}</h2>
      <button onClick={() => dispatch(increment())}>
        증가
      </button>
      <button onClick={() => dispatch(decrement())}>
        감소
      </button>
      <button onClick={() => dispatch(incrementByAmount(5))}>
        5 증가
      </button>
    </div>
  );
}

export default Counter;
```

## 비동기 작업 (Thunk)

```typescript
// store/userSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

interface User {
  id: number;
  name: string;
  email: string;
}

interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
}

const initialState: UserState = {
  users: [],
  loading: false,
  error: null
};

// 비동기 thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('https://api.example.com/users');
    return response.json();
  }
);

const userSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || '오류가 발생했습니다';
      });
  }
});

export default userSlice.reducer;
```

```tsx
// UserList.tsx
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchUsers } from './store/userSlice';
import type { RootState, AppDispatch } from './store';

function UserList() {
  const { users, loading, error } = useSelector((state: RootState) => state.users);
  const dispatch = useDispatch<AppDispatch>();

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>오류: {error}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name} ({user.email})
        </li>
      ))}
    </ul>
  );
}

export default UserList;
```

## 언제 사용하나요?

- 여러 컴포넌트가 같은 상태를 공유할 때
- 복잡한 상태 로직이 필요할 때
- 상태 변경을 추적하고 디버깅해야 할 때
- 대규모 애플리케이션에서 예측 가능한 상태 관리가 필요할 때

## 대안

- **Zustand**: 더 간단한 API
- **Jotai**: 원자적 상태 관리
- **MobX**: 반응형 상태 관리
- **React Context**: 간단한 전역 상태

## 추가 자료

- [공식 문서](https://redux.js.org)
- [Redux Toolkit](https://redux-toolkit.js.org)
- [Redux DevTools](https://github.com/reduxjs/redux-devtools)

